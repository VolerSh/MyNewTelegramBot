# os: Модуль для взаимодействия с операционной системой.
# Мы используем его для управления переменными окружения, в частности,
# для очистки настроек прокси, которые могут мешать работе бота.
import os

# time: Модуль для работы со временем.
# Нужен для создания искусственной задержки (time.sleep), чтобы
# дать API Telegram время на полную инициализацию перед отправкой сообщения.
import time

# telebot: Основная библиотека для создания Telegram-ботов (pyTelegramBotAPI).
# Предоставляет все необходимые инструменты для отправки сообщений,
# обработки команд и взаимодействия с Telegram API.
import telebot

# threading: Модуль для работы с потоками.
# Позволяет выполнять задачи параллельно. Мы используем его, чтобы
# запустить отправку приветственного сообщения в отдельном потоке,
# не блокируя при этом основную функцию, которая слушает входящие сообщения.
import threading

# config: Наш собственный файл (config.py), где хранятся константы.
# Импортируем оттуда токен бота и ID пользователя, чтобы не "светить" их в основном коде.
from ..config import BOT_TOKEN, YOUR_TELEGRAM_CHAT_ID

# handlers: Наш собственный файл (handlers.py), где хранятся обработчики сообщений.
# Импортируем оттуда функцию регистрации обработчиков.
from .handlers import register_all_handlers

# --- Начало основного кода ---

# Шаг 1: Подготовка окружения
# Радикальный, но эффективный метод борьбы с ProxyError.
# Если в вашей операционной системе (например, в Windows) глобально настроен прокси-сервер,
# библиотека requests (которую использует telebot) попытается подключиться через него.
# Это часто приводит к ошибкам, если прокси не настроен для доступа к Telegram.
# Очищая эти переменные окружения, мы заставляем библиотеку подключаться напрямую.
print("Очистка переменных окружения HTTP_PROXY и HTTPS_PROXY...")
os.environ['HTTP_PROXY'] = ''
os.environ['HTTPS_PROXY'] = ''
print("Переменные окружения очищены.")

# Шаг 2: Инициализация бота
# Создаем главный объект 'bot', который будет управлять всеми операциями.
# Мы передаем ему токен, полученный из файла config.py.
print("Инициализация экземпляра бота...")
bot = telebot.TeleBot(BOT_TOKEN)
print("Экземпляр бота создан.")

def send_startup_message_with_delay():
    """
    Отправляет сообщение о готовности после небольшой задержки.
    Эта функция выполняется в отдельном потоке.
    """
    try:
        # Даем боту 5 секунд на "прогрев". За это время telebot успевает
        # установить соединение с серверами Telegram и полностью инициализироваться.
        # Без этой задержки попытка отправить сообщение может провалиться.
        print("[Поток отправки сообщения]: Ожидание 5 секунд...")
        time.sleep(5)
        
        # Перед отправкой проверяем, что ID пользователя указан в конфиге.
        # Это предотвратит падение, если переменная пуста.
        if YOUR_TELEGRAM_CHAT_ID:
            print(f"[Поток отправки сообщения]: Отправка сообщения пользователю с ID {YOUR_TELEGRAM_CHAT_ID}...")
            bot.send_message(YOUR_TELEGRAM_CHAT_ID, "Бот запущен и готов к работе.")
            print("[Поток отправки сообщения]: Сообщение о готовности успешно отправлено.")
        else:
            # Если ID не найден, выводим ошибку в консоль.
            print("[Поток отправки сообщения]: Ошибка! YOUR_TELEGRAM_CHAT_ID не найден в файле config.py. Сообщение о запуске не отправлено.")
            
    except Exception as e:
        # Ловим любые возможные ошибки при отправке (например, неверный ID, проблемы с сетью).
        print(f"[Поток отправки сообщения]: КРИТИЧЕСКАЯ ОШИБКА при отправке стартового сообщения: {e}")

def start_bot():
    """
    Основная функция, которая запускает и координирует работу бота.
    """
    print("[Основной поток]: Запуск бота...")
    
    # Регистрируем обработчики сообщений
    print("[Основной поток]: Регистрация обработчиков сообщений...")
    register_all_handlers(bot)
    print("[Основной поток]: Обработчики сообщений зарегистрированы.")
    
    # Создаем и запускаем отдельный поток для отправки приветственного сообщения.
    # target=send_startup_message_with_delay - указываем, какую функцию выполнять в потоке.
    # daemon=True - это флаг, который говорит, что этот поток не является критически важным.
    # Если основная программа завершится, этот поток будет принудительно остановлен.
    print("[Основной поток]: Запуск потока для отправки приветственного сообщения...")
    startup_thread = threading.Thread(target=send_startup_message_with_delay)
    startup_thread.daemon = True
    startup_thread.start()
    
    # Самая важная часть: запуск "поллинга".
    # bot.polling() - это блокирующая функция, которая устанавливает бесконечный цикл.
    # В этом цикле бот постоянно опрашивает серверы Telegram на наличие новых сообщений.
    # none_stop=True - говорит продолжать опрос даже при возникновении некоторых ошибок.
    # skip_pending=True - говорит проигнорировать все сообщения, которые пришли боту,
    # пока он был выключен. Это полезно, чтобы не отвечать на старые команды.
    print("[Основной поток]: Бот переходит в режим постоянного опроса (polling)...")
    bot.polling(none_stop=True, skip_pending=True)

# Эта конструкция `if __name__ == '__main__':` является стандартной точкой входа в Python.
# Код внутри этого блока выполнится только в том случае, если вы запустите этот файл
# напрямую (например, командой `python app/telegram_bot/bot.py`).
# Если же этот файл будет импортирован в другой файл (как модуль),
# то код внутри блока НЕ выполнится. Это позволяет безопасно импортировать функции.
if __name__ == '__main__':
    start_bot()